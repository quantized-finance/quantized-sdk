{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/constants.ts","../src/errors.ts","../src/entities/token.ts","../src/entities/quantize.ts"],"sourcesContent":["  \r\nimport JSBI from 'jsbi'\r\n\r\nexport const QUANTIZED_ADDRESS = '0x8c1f3365F11cf2E401340CD2425dDBcefa300040'\r\nexport const FACTORY_ADDRESS = '0xEf27F45DB678Fa3FC35d73E86D239E12f8e26FD7'\r\nexport const MULTITOKEN_ADDRESS = '0xf377E4CDd42C3Acf37D01dB69Fe8E669c7Afb11B'\r\nexport const FEETRACKER_ADDRESS = '0xea6EC95E6FdeD7B30c147979c8CC76B729ac3d16'\r\nexport const QUANTA_ADDRESS = '0x7017453C48d67f8C63e0335d6781CB49089b26cF'\r\n\r\nexport const QUANTIZED_ERC20_INIT_CODE_HASH = '0xcd4902b65e1285dd3266dd5a6212b18ff94b962e082ca6cd0a3c4538738b4a96'\r\n\r\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\r\n\r\nexport enum QuantizeType {\r\n    QUANTIZE = 0,\r\n    QUANTIZE_ETH = 1,\r\n    DEQUANTIZE = 2\r\n}\r\n\r\n// exports for internal consumption\r\nexport const ZERO = JSBI.BigInt(0)\r\nexport const ONE = JSBI.BigInt(1)\r\nexport const FIVE = JSBI.BigInt(5)\r\nexport const _999 = JSBI.BigInt(999)\r\nexport const _1000 = JSBI.BigInt(1000)","// see https://stackoverflow.com/a/41102306\r\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\r\n\r\n/**\r\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\r\n * obtained by sending any amount of input.\r\n */\r\nexport class InsufficientQuantaAvailableError extends Error {\r\n  public readonly isInsufficientQuantaAvailableError: true = true\r\n\r\n  public constructor() {\r\n    super()\r\n    this.name = this.constructor.name\r\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\r\n  }\r\n}\r\n\r\n","import invariant from 'tiny-invariant'\r\nimport {validateAndParseAddress } from '@uniswap/sdk-core'\r\nimport { ChainId, Currency, Token } from '@uniswap/sdk-core'\r\nimport { pack, keccak256 } from '@ethersproject/solidity'\r\nimport { getCreate2Address } from '@ethersproject/address'\r\n\r\nimport { FACTORY_ADDRESS, QUANTIZED_ADDRESS, MULTITOKEN_ADDRESS,  QUANTIZED_ERC20_INIT_CODE_HASH, QUANTA_ADDRESS } from '../constants'\r\n\r\nexport const computeQuantizedAddress = ({\r\n  tokenAddress\r\n}: {\r\n  tokenAddress: string\r\n}): string => {\r\n  return getCreate2Address(\r\n    FACTORY_ADDRESS,\r\n    keccak256(['bytes','bytes','bytes'], [pack(['address'], [QUANTIZED_ADDRESS]),pack(['address'], [MULTITOKEN_ADDRESS]),pack(['address'], [tokenAddress])]),\r\n    QUANTIZED_ERC20_INIT_CODE_HASH\r\n  )\r\n}\r\n\r\nexport class QuantizedToken extends Token {\r\n\r\n  public readonly token: Token;\r\n\r\n  public constructor(chainId: ChainId | number, address: string, decimals: number, symbol?: string, name?: string) {\r\n    super(chainId, validateAndParseAddress(computeQuantizedAddress({tokenAddress:address})), decimals, `^${symbol}`, `Quantized ${name}`)\r\n    this.token = new Token(chainId, address, decimals, symbol, name);\r\n  }\r\n\r\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\r\n  public equals(other: QuantizedToken): boolean {\r\n    // short circuit on reference equality\r\n    if (this === other) {\r\n      return true\r\n    }\r\n    return this.chainId === other.chainId && this.address === other.address && this.token === other.token\r\n  }\r\n\r\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */\r\n  public sortsBefore(other: Token): boolean {\r\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\r\n    invariant(this.address !== other.address, 'ADDRESSES')\r\n    return this.address.toLowerCase() < other.address.toLowerCase()\r\n  }\r\n}\r\n\r\n/**\r\n * Compares two currencies for equality\r\n */\r\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\r\n  if (currencyA instanceof Token && currencyB instanceof Token) {\r\n    return currencyA.equals(currencyB)\r\n  } else if (currencyA instanceof Token) {\r\n    return false\r\n  } else if (currencyB instanceof Token) {\r\n    return false\r\n  } else {\r\n    return currencyA === currencyB\r\n  }\r\n}\r\n\r\n\r\nexport const QUANTA: { [chainId in ChainId]: QuantizedToken } = {\r\n  [ChainId.MAINNET]: new QuantizedToken(\r\n    ChainId.MAINNET,\r\n    QUANTA_ADDRESS,\r\n    18,\r\n    'QUANTA',\r\n    'Quanta'\r\n  ),\r\n  [ChainId.ROPSTEN]: new QuantizedToken(\r\n    ChainId.ROPSTEN,\r\n    QUANTA_ADDRESS,\r\n    18,\r\n    'QUANTA',\r\n    'Quanta'\r\n  ),\r\n  [ChainId.RINKEBY]: new QuantizedToken(\r\n    ChainId.RINKEBY,\r\n    QUANTA_ADDRESS,\r\n    18,\r\n    'QUANTA',\r\n    'Wrapped Ether'\r\n  ),\r\n  [ChainId.GÖRLI]: new QuantizedToken(ChainId.GÖRLI, QUANTA_ADDRESS, 18, 'QUANTA', 'Wrapped QUANTA'),\r\n  [ChainId.KOVAN]: new QuantizedToken(ChainId.KOVAN, QUANTA_ADDRESS, 18, 'QUANTA', 'Wrapped QUANTA')\r\n}\r\n","import {\r\n  ChainId,\r\n  Currency,\r\n  CurrencyAmount,\r\n  ETHER,\r\n  Token,\r\n  TokenAmount\r\n} from '@uniswap/sdk-core'\r\n\r\nimport { QUANTA, QuantizedToken } from '../entities/token'\r\n\r\nimport { QuantizeType } from '../constants'\r\n\r\nimport invariant from 'tiny-invariant'\r\n\r\n/**\r\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\r\n * In other words, if the currency is ETHER, returns the WETH9 token amount for the given chain. Otherwise, returns\r\n * the input currency amount.\r\n */\r\nexport function quantizedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\r\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\r\n  if (currencyAmount.currency === ETHER) return new TokenAmount(QUANTA[chainId], currencyAmount.raw)\r\n  invariant(false, 'CURRENCY')\r\n}\r\n\r\nexport function quantizedCurrency(currency: Currency, chainId: ChainId): Token {\r\n  if (currency instanceof Token) return currency\r\n  if (currency === ETHER) return QUANTA[chainId]\r\n  invariant(false, 'CURRENCY')\r\n}\r\n\r\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\r\nexport class Quantize {\r\n  /**\r\n   * The token or currency \r\n   */\r\n  public readonly token: Token | QuantizedToken | Currency\r\n  /**\r\n   * The type of the quantize op\r\n   */\r\n  public readonly tradeType: QuantizeType\r\n  /**\r\n   * The input amount for the quantize\r\n   */\r\n  public readonly inputAmount: CurrencyAmount\r\n  /**\r\n   * The output amount for the quantize after fees\r\n   */\r\n  public readonly outputAmount: CurrencyAmount\r\n\r\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\r\n  public static quantize(token: Token, amountIn: CurrencyAmount): Quantize {\r\n    return new Quantize(token, amountIn, QuantizeType.QUANTIZE)\r\n  }\r\n\r\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\r\n  public static quantizeEth(token: Currency, amountIn: CurrencyAmount): Quantize {\r\n    return new Quantize(token, amountIn, QuantizeType.QUANTIZE_ETH)\r\n  }\r\n\r\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\r\n    public static dequantize(token: QuantizedToken, amountIn: CurrencyAmount): Quantize {\r\n    return new Quantize(token, amountIn, QuantizeType.DEQUANTIZE)\r\n  }\r\n\r\n\r\n  public constructor(token: Token | QuantizedToken | Currency, amount: CurrencyAmount, quantizeType: QuantizeType) {\r\n\r\n    this.token = token\r\n    this.tradeType = quantizeType\r\n    this.inputAmount =\r\n    quantizeType === QuantizeType.QUANTIZE || QuantizeType.DEQUANTIZE\r\n        ? amount\r\n        : CurrencyAmount.ether(amount.raw)\r\n    this.outputAmount =\r\n    quantizeType === QuantizeType.QUANTIZE || QuantizeType.DEQUANTIZE\r\n        ? amount\r\n        : CurrencyAmount.ether(amount.raw)\r\n\r\n  }\r\n\r\n}"],"names":["QuantizeType","QUANTA_ADDRESS","CAN_SET_PROTOTYPE","Object","InsufficientQuantaAvailableError","name","_this","constructor","setPrototypeOf","prototype","Error","computeQuantizedAddress","tokenAddress","getCreate2Address","keccak256","pack","QuantizedToken","chainId","address","decimals","symbol","validateAndParseAddress","token","Token","equals","other","this","sortsBefore","invariant","toLowerCase","QUANTA","ChainId","MAINNET","ROPSTEN","RINKEBY","GÖRLI","KOVAN","Quantize","amount","quantizeType","tradeType","inputAmount","QUANTIZE","DEQUANTIZE","CurrencyAmount","ether","raw","outputAmount","quantize","amountIn","quantizeEth","QUANTIZE_ETH","dequantize","currencyA","currencyB","currencyAmount","TokenAmount","currency","ETHER"],"mappings":"0FAaYA,yLANCC,EAAiB,qwCAM9B,SAAYD,GACRA,2BACAA,mCACAA,+BAHJ,CAAYA,IAAAA,OCZZ,MAAME,EAAoB,mBAAoBC,OAMjCC,kGACgD,IAIpDC,KAAOC,EAAKC,YAAYF,KACzBH,GAAmBC,OAAOK,wLAAgCC,gCANZC,QCCzCC,EAA0B,gBACrCC,IAAAA,oBAIOC,oBFTsB,6CEW3BC,YAAU,CAAC,QAAQ,QAAQ,SAAU,CAACC,OAAK,CAAC,WAAY,CFZ3B,+CEYgDA,OAAK,CAAC,WAAY,CFVjE,+CEUuFA,OAAK,CAAC,WAAY,CAACH,MFN9F,uEEWjCI,yBAIQC,EAA2BC,EAAiBC,EAAkBC,EAAiBf,8BAC1FY,EAASI,0BAAwBV,EAAwB,CAACC,aAAaM,KAAYC,MAAcC,eAAuBf,UACzHiB,MAAQ,IAAIC,QAAMN,EAASC,EAASC,EAAUC,EAAQf,uCAOtDmB,OAAA,SAAOC,UAERC,OAASD,GAGNC,KAAKT,UAAYQ,EAAMR,SAAWS,KAAKR,UAAYO,EAAMP,SAAWQ,KAAKJ,QAAUG,EAAMH,SAS3FK,YAAA,SAAYF,UACPC,KAAKT,UAAYQ,EAAMR,SAAjCW,MACUF,KAAKR,UAAYO,EAAMP,SAAjCU,MACOF,KAAKR,QAAQW,cAAgBJ,EAAMP,QAAQW,kBA9BlBN,SAkDvBO,UACVC,UAAQC,SAAU,IAAIhB,EACrBe,UAAQC,QACR/B,EACA,GACA,SACA,YAED8B,UAAQE,SAAU,IAAIjB,EACrBe,UAAQE,QACRhC,EACA,GACA,SACA,YAED8B,UAAQG,SAAU,IAAIlB,EACrBe,UAAQG,QACRjC,EACA,GACA,SACA,mBAED8B,UAAQI,OAAQ,IAAInB,EAAee,UAAQI,MAAOlC,EAAgB,GAAI,SAAU,oBAChF8B,UAAQK,OAAQ,IAAIpB,EAAee,UAAQK,MAAOnC,EAAgB,GAAI,SAAU,qBCzDtEoC,wBA8CQf,EAA0CgB,EAAwBC,QAE9EjB,MAAQA,OACRkB,UAAYD,OACZE,YACLF,IAAiBvC,EAAa0C,UAAY1C,EAAa2C,WACjDL,EACAM,iBAAeC,MAAMP,EAAOQ,UAC7BC,aACLR,IAAiBvC,EAAa0C,UAAY1C,EAAa2C,WACjDL,EACAM,iBAAeC,MAAMP,EAAOQ,cAlCtBE,SAAP,SAAgB1B,EAAc2B,UAC5B,IAAIZ,EAASf,EAAO2B,EAAUjD,EAAa0C,aAQtCQ,YAAP,SAAmB5B,EAAiB2B,UAClC,IAAIZ,EAASf,EAAO2B,EAAUjD,EAAamD,iBAQpCC,WAAP,SAAkB9B,EAAuB2B,UACzC,IAAIZ,EAASf,EAAO2B,EAAUjD,EAAa2C,0CH1EvB,wEAEG,mHADA,wFAFD,oFAMa,mLEgDfU,EAAqBC,UAC9CD,aAAqB9B,SAAS+B,aAAqB/B,QAC9C8B,EAAU7B,OAAO8B,KACfD,aAAqB9B,SAErB+B,aAAqB/B,SAGvB8B,IAAcC,qCC7COC,EAAgCtC,UAC1DsC,aAA0BC,cAAoBD,EAC9CA,EAAeE,WAAaC,QAAc,IAAIF,cAAY1B,EAAOb,GAAUsC,EAAeT,UAC9FlB,0CAGgC6B,EAAoBxC,UAChDwC,aAAoBlC,QAAckC,EAClCA,IAAaC,QAAc5B,EAAOb,QACtCW"}